% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/callGetLLBySample.R
\name{callGetLLBySample}
\alias{callGetLLBySample}
\title{Function callGetLLBySample}
\usage{
callGetLLBySample(
  sample_effect,
  gene_effects,
  use_genes = NA,
  use_sample,
  guide_efficiency,
  user_DataObj,
  user_ModelObj
)
}
\arguments{
\item{sample_effect}{Tuple sample effect parameter.}

\item{gene_effects}{Numeric vector of gene essentiality parameters.}

\item{use_genes}{Subset of gene names to use (optional).}

\item{use_sample}{Sample index corresponding to sample_effect.}

\item{guide_efficiency}{Numeric vector of guide efficiency weights.}

\item{user_DataObj}{DataObject with experimental data to analyze.}

\item{user_ModelObj}{ModelObject with preprocessed model parameters.}
}
\description{
Calls Rcpp functions to evaluate the likelihood of a single SAMPLE parameter
given gene and guide parameters. Assumes sample independence.
  
If there is no initial sequencing, there is only lambda' (ModelObj$dep_scaling).
If there is initial sequencing, there is also lambda (ModelObj$init_scaling).
There is no scaling term for either form of the nsg prior (uniform or 
masterlibrary based); numerical evaluation is presumed to adjust lambda
to re-scale nsg to counts, assuming a linear relationship between observed counts
and the estimated prior as described by lambda.
}
